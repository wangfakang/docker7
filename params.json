{"name":"Docker7","tagline":"docker cmd and entrypoint questions","body":"`关于dockerfile中CMD以及ENTRYPOINT命令的解析：`\r\n\r\n　 之前只是对这两个命令简单做了下解释，但是今天实战了一下　踩了一些坑：     \r\n\r\n首先说一些CMD的写法吧：   \r\nCMD 有三种写法：     \r\n     CMD [\"executable\",\"param1\",\"param2\"] (exec form, this is the preferred form)    \r\n     CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT)    \r\n     CMD command param1 param2 (shell form)     \r\n\r\n坑坑１:\r\n===\r\n在所写的CMD [] 方式的时候一定要注意CMD 和[]之间是要空格隔开的，否则build就会出错．\r\n\r\n\r\n坑坑２:\r\n===\r\n在写下面格式CMD时候：   \r\n\r\n* CMD \"echo\" , \"test\"  // will output [/bin/sh: 1: echo,: not found]     \r\n* CMD echo , \"test\"   // will output  [, test]  注意之间试不用写逗号隔开的\r\ncmd的第三种写法后面的参数是指所要执行命令的参数（如:ps aux \\ ls -c）等\r\n\r\n坑坑３:\r\n===\r\n之前一直认为CMD中命令只会被run后面同样的命令覆盖，其实不是这样的，而是都是可以替代的．\r\n\r\n\r\n坑坑４:\r\n===\r\n通过查看docker inspect查看image，看到CMD [\"execute\"] 和　CMD execute的区别：\r\n\r\n如：   \r\n\r\n* CMD[\"/bin/echo\",\"hello\"]    \r\n　　　docker解析后如下：     \r\n```\r\n        \"Cmd\": [\r\n            \"/bin/echo\",\r\n            \"test\"\r\n        ]\r\n```\r\n* CMD /bin/echo \"hello\"\r\n　　　docker解析后如下：\r\n```     \r\n        \"Cmd\": [\r\n            \"/bin/sh\",\r\n            \"-c\",\r\n            \"/bin/echo  \\\"test\\\"\"\r\n        ]\r\n```\r\n看到了嘛，不要[]会多一个/bin/sh　－c．也就是说CMD后面不要中括号的话则是在shell中执行．而有中括号的则\r\nexec:shell的内建命令exec将并不启动新的shell，而是用要被执行命令替换当前的shell进程，并且将老进程的环\r\n境清理掉，而且exec命令后的其它命令将不再执行。  \r\n \r\n\r\n还有一个简单的现象可以对比：\r\n\r\n* CMD echo $HOME\r\n命令最终解析为：\r\n        \"Cmd\": [\r\n            \"/bin/sh\",\r\n            \"-c\",\r\n            \"#(nop) CMD [/bin/sh -c echo $HOME]\"\r\n        ]\r\n\r\n* CMD [\"echo\", \"$HOME\"]\r\n命令最终解析为：  \r\n```\r\n        \"Cmd\": [\r\n            \"/bin/sh\",\r\n            \"-c\",\r\n            \"#(nop) CMD [echo $HOME]\"\r\n        ]\r\n```\r\n\r\n以上两条在第一个中$HOME可以被解析出来，而第二个却输出$HOME字符串．\r\n其实官网上有解决办法：CMD [\"/bin/sh\", \"-c\", \"echo\", \"$HOME\"]\r\n```\r\n        \"Cmd\": [\r\n            \"/bin/sh\",\r\n            \"-c\",\r\n            \"#(nop) CMD [/bin/sh -c echo $HOME]\"\r\n        ]\r\n```\r\n这样的话效果就和CMD echo $HOME一样了．\r\n\r\n\r\n* CMD [\"sh\", \"-c\", \"echo\", \"$HOME\"]如下：\r\n```\r\n\r\n        \"Cmd\": [\r\n            \"/bin/sh\",\r\n            \"-c\",\r\n            \"#(nop) CMD [sh -c echo $HOME]\"\r\n        ]\r\n```\r\n上面输出的是空字符串．\r\n\r\n\r\n\r\n最后就是ENTRYPOINT了其实和上面的CMD很相似吧，只不过是ENTRYPOINT不会被docker run中的给的命令参数覆盖．\r\n当然还有就是CMD的第二种写法　向ENTRYPOINT提供参数：这种应用场景\r\nCMD可以为ENTRYPOINT提供参数，ENTRYPOINT本身也可以包含参数，但是你可以把那些可能需要变动的参数写到CMD\r\n里而把那些不需要变动的参数写到ENTRYPOINT里面例如：  \r\n\r\n    FROM ubuntu:14.10  \r\n    ENTRYPOINT [\"top\", \"-b\"]   \r\n    CMD [\"-c\"]  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"some differents points about docker CMD and ENTRYPOINT or RUN","note":"Don't delete this file! It's used internally to help with page regeneration."}